---
tags:
  - 嵌入式/编程语言/CPP
number headings: " first-level l, start-at 1, max 6, l.l, auto, contents"
aliases:
---
> 如果喜欢看图文讲解，可点击下方链接，或搜索硬核萌新实验室
> - 小红书： 
> - 公众号： 


> [!abstract]  
> 运算符不仅是数学计算符号，更是 C++ 让自定义对象（如类）拥有和内置类型（如 `int`）同等待遇的核心手段。基础看语法，进阶看语义，底层看函数调用本质。

# 1 基础概念

## 1.1 是什么？

- **直观定义**：指挥数据进行交互的“指令符”。
- **生活化比喻**：
    - `+`, `-` 就像乐高积木的接口，把两块积木拼在一起。
    - `.` (点运算符) 就像遥控器的按钮，`电视.开机()`。
    - `<<` (流运算符) 就像水管，`cout << "水"` 把数据导向屏幕。
- **核心作用**：在最简单的程序里，它负责数据的计算、比较和流转。

C++ 的常用运算符如下：

| 类别       | 运算符                 | 比喻                                                   | 核心作用                        |
| -------- | ------------------- | ---------------------------------------------------- | --------------------------- |
| **算术**   | `+` `-` `*` `/` `%` | **计算器**：按键算出结果。`%` 就像切蛋糕剩下的“余数”。                     | 处理数值数据的变换。                  |
| **赋值**   | `=`                 | **收纳盒**：把右边的东西（值）放进左边的盒子（变量）里。                       | 保存计算结果。                     |
| **比较**   | `==` `!=` `<` `>`   | **天平/量尺**：天平平衡就是 `==`，一边高一边低就是 `<` 或 `>`。            | 产生 `true` 或 `false`，决定程序走向。 |
| **逻辑**   | `&&` `              | !`                                                   | **组合条件**                    |
| **访问**   | `.`                 | **遥控器按键**：`电视.开机()`，直接控制手边的对象。                       | 访问栈上或引用对象的成员。               |
| **指针访问** | `->`                | **无人机遥控**：你手里拿着遥控器（指针），操作远处的无人机（对象）动作。`ptr->fly()`。  | 访问堆上或指针指向对象的成员。             |
| **自增减**  | `++` `--`           | **计数器**：像机场门口保安手里的计数器，按一下加 1。                        | 循环计数、迭代器移动。                 |
| **输入输出** | `<<` `>>`           | **水管接头**：`cout << "水"` 是把水引向屏幕；`cin >> x` 是把水引向变量 x。 | 数据的流入与流出。                   |
| **内存**   | `new` `delete`      | **租房合同**：`new` 是签合同拿钥匙（申请堆内存），`delete` 是退房还钥匙。       | 动态管理资源的生命周期。                |
| **侦测**   | `sizeof`            | **X 光扫描**：不运行代码，编译期直接扫描出对象占多大地方（字节数）。                | 内存分配、序列化时的容量判断。             |

## 1.2 怎么用？

- **内置类型行为**：对于 `int`、`float`，编译器内置了处理逻辑。
- **优先级与常见陷阱**：
    - **整数除法陷阱**：`int a = 1/2;` 结果是 0，不是 0.5。
    - **短路求值**：`A && B`，如果 A 为假，B 根本不会执行。这是保护程序崩溃的重要机制（例如 `ptr && ptr->value`）。

```
#include <iostream>

int main() {
    // 算术运算符
    int a = 10, b = 3;
    // 记住：整数除法只保留整数部分，结果是 3
    int div = a / b;
    // 取模拿到余数，结果是 1
    int rem = a % b;

    // 自增自减（前置 vs 后置）
    int i = 0;
    int j = i++; // 后置：先赋值，再自增。j=0, i=1 (产生临时副本，性能略低)
    int k = ++i; // 前置：先自增，再赋值。k=2, i=2 (无临时副本，推荐)

    // 逻辑运算符与短路
    int* ptr = nullptr;
    // 如果不短路，ptr->value 会导致崩溃。因为 ptr 为空，右边直接跳过。
    if (ptr && *ptr == 10) {
        std::cout << "Never executes" << std::endl;
    }

    return 0;
}
```

## 1.3 常见错误

- **经典错误 1**：混淆 `=` (赋值) 和 `==` (相等)。
    - *现象*：`if (x = 5)` 永远为真（除非 x 是 0），且 x 被修改。
    - *做法*：养成 `if (5 == x)` 的“尤达写法”习惯，或者开启编译器警告。
- **经典错误 2**：无符号数的减法下溢。
    - *现象*：`unsigned int x = 0; x - 1` 会变成一个巨大的正数（42 亿多）。
    - *做法*：循环计数器涉及减法时，尽量用有符号 `int`。
- **易混淆概念**：`&` (位与) vs `&&` (逻辑与)。前者按二进制位操作（不短路），后者按真假逻辑操作（短路）。

| 特性         | `&` (位与)      | `&&` (逻辑与)     |
| ---------- | ------------- | -------------- |
| ​**操作对象**​ | 整数的二进制位       | 布尔值（真/假）       |
| ​**计算方式**​ | 对**每一位**进行与操作 | 对**整个值**进行与操作  |
| ​**短路求值**​ | ❌ 无，两边都计算     | ✅ 有，左边为假则右边不计算 |
| ​**典型用途**​ | 掩码操作、权限判断     | 条件判断、逻辑运算      |

# 2 进阶实战

## 2.1 进阶用法

- **为什么要进阶？**：为了让自定义类型（如 `BigInt`、`Vector`）写起来像内置类型一样自然。`matrixC = matrixA + matrixB` 显然比 `matrixC = matrixA.add(matrixB)` 更具表现力。
- **核心原则**：运算符重载的本质是**函数重载**。
	- **成员函数版本**​：`a + b`
	    - 被编译器解释为：`a.operator+(b)`
	    - **隐含的 `this` 指针**​：运算符作用于一个**明确的、已存在的对象**​（`a`）。运算符函数可以直接访问该对象的所有成员（包括私有成员）
	- **非成员函数版本**​：`a + b`
		- 被编译器解释为：`operator+(a, b)`
		- ​**无隐含的 `this` 指针**​：它将两个操作数 `a` 和 `b` 视为平等的参数。如果需要访问私有成员，通常需要将该函数声明为类的**友元​**。

```
#include <iostream>

class Vector2D {
private:
    float x, y;

public:
    Vector2D(float _x, float _y) : x(_x), y(_y) {}

    // 成员函数重载 +=
    // 建议：复合赋值（+=, -=）通常作为成员函数，返回引用以支持连写 (a+=b)+=c
    Vector2D& operator+=(const Vector2D& rhs) {
        this->x += rhs.x;
        this->y += rhs.y;
        return *this; // 返回自身引用
    }

    // 必须作为非成员函数的 <<
    // 解释：如果做成成员函数，用法会变成 v << cout，不符合习惯。
    // 为了访问私有成员 x, y，通常设为 friend
    friend std::ostream& operator<<(std::ostream& os, const Vector2D& v) {
        os << "(" << v.x << ", " << v.y << ")";
        return os; // 返回流引用，支持 cout << a << b;
    }

    // 为了支持非成员函数的 operator+ 访问
    float getX() const { return x; }
    float getY() const { return y; }
};

// 非成员函数重载 +
// 建议：双目运算符（+, -, *）通常作为非成员函数。
// 理由：利用 += 实现，且支持对称的隐式转换（如 2 + v 和 v + 2）
Vector2D operator+(Vector2D lhs, const Vector2D& rhs) {
    lhs += rhs; // 复用 +=，减少代码重复
    return lhs; // 返回值优化（RVO）
}

int main() {
    Vector2D v1(1.0, 2.0);
    Vector2D v2(3.0, 4.0);
    v1 += v2; // 调用成员函数
    std::cout << v1 << std::endl; // 调用非成员 friend 函数
}
```

## 2.2 常见错误

- **反模式**：不要重载 `&&`, `||`, `,` (逗号)。
    - *原因*：重载后它们变成了普通函数调用，**会失去短路求值特性**。`operator&&(a, b)` 会先把 a 和 b 都计算出来，如果 a 失败了 b 还会执行，极度危险。
- **特别注意**：`operator[]` 必须返回引用才能作为左值（即 `arr = 5`）。

## 2.3 工程习惯

- **嵌入式/驱动开发**：
    - 在资源受限的嵌入式开发环境下，尽量少用复杂的运算符重载，避免隐藏的函数调用开销。
    - **位操作**：`|` (置位), `&` (清零), `^` (翻转) 是驱动开发的灵魂。我们可以用宏或 `constexpr` 定义掩码，配合位运算符操作寄存器。
    - **智能指针**：重载 `->` 和 `*` 是为了让对象表现得像指针，在资源管理类（RAII）中必用。

# 3 底层原理

## 3.1 编译器视角

- **编译本质**：当你写 `c = a + b` 时，编译器实际是在找名为 `operator+` 的函数。
    - 它会先在类成员里找 `a.operator+(b)`。
    - 找不到再去全局找 `operator+(a, b)` (依赖 ADL 查找规则)。
- **常量折叠**：对于 `const int a = 2 + 3;`，编译器在编译期直接算出 5，运行时没有加法指令。

## 3.2 内存与性能

- **临时对象消除**：
    - 在 `operator+` 中返回 `Vector2D`（值类型）通常不会导致拷贝。现代 C++ (C++17 起) 强制执行 **返回值优化**。编译器直接在接收变量的内存地址上构造结果，零拷贝。
- **移动语义 (C++11)**：
    - `operator=` 是性能关键点。传统赋值是深拷贝，C++11 引入了 `operator=(Class&& rhs)` (移动赋值)。
    - **原理**：直接“窃取”临时对象（右值）内部的指针（如堆内存资源），并将原指针置空，避免了昂贵的 `new/delete` 和内存复制。

```
// 移动赋值示例（伪代码）
MyString& operator=(MyString&& other) noexcept {
    if (this != &other) {
        delete[] data;       // 释放自己的旧资源
        data = other.data;   // 偷取对方的指针
        other.data = nullptr;// 把对方置空，防止析构时重复释放
    }
    return *this;
}
```

# 4 总结

## 4.1 设计哲学

- **表现力优于形式**：运算符重载的初衷是让自定义类型的使用符合直觉。
- **零开销抽象**：如果合理使用（配合 `inline`），运算符重载生成的汇编代码应与手写 C 语言加法完全一致，没有额外运行时开销。

## 4.2 现代 C++ 演进

- **C++20 太空船运算符 `<=>`**：
    - 以前要写 `==, !=, <, <=, >, >=` 6 个函数。
    - 现在只需写一个 `auto operator<=>(const T&) const = default;`，编译器自动生成所有比较逻辑。这也是编译器“编译期生成代码”能力的体现。

## 4.3 本质

**运算符重载本质上就是“函数调用”的语法糖，但在 C++11 移动语义加持下，它成为了高性能资源管理的关键载体。**

> [!question] 问题自测
>
> - **基础题**：`i++` 和 `++i` 的区别是什么？在自定义迭代器中哪个性能更好？为什么？
>     - *思路*：后置需要保存旧值副本，对于复杂对象（如 `std::map::iterator`），拷贝构造开销大。前置返回引用，无拷贝。
> - **进阶题**：为什么 `operator=` 必须返回 `*this` 的引用？如果不返回引用会发生什么？
>     - *思路*：为了支持连续赋值 `a = b = c`。若不返回引用，无法作为左值，或者导致多余拷贝。
> - **地狱题**：如何设计一个智能指针的 `operator->`？编译器是如何递归解析箭头运算符的？
>     - *思路*：`ptr->func()` 被编译器转化为 `(ptr.operator->())->func()`。编译器会一直递归调用 `operator->` 直到得到一个原生指针。


