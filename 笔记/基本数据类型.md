---
tags:
  - 嵌入式/编程语言/CPP
number headings: " first-level l, start-at 1, max 6, l.l, auto, contents"
aliases:
---
> 如果喜欢看图文讲解，可点击下方链接，或搜索硬核萌新实验室
> - 小红书： http://xhslink.com/o/79yMsFe3sar 
> - 公众号： https://mp.weixin.qq.com/s/KwjZAlnI-KcT8ZfHJKYOGQ


> [!abstract]  
> 基本数据类型**是 C++ 构建万物的“量杯规格”**，它规定了程序在内存中占地的**尺寸**；而**变量与常量**是数据的“房间”，通过具名的**内存位置**实现对电信号的精准操控。

# 1 基本概念

## 1.1 是什么

- **一句话定义**：数据类型是编译器预设的存储规格，变量是内存地址的绰号，常量是焊死的保险箱。
- **生活化比喻**：内存是一个巨大的**储物超市**。**基本类型**就是不同规格的**包装盒**（小盒装回形针，大盒装家电）；**变量**是贴在盒子上的**姓名标签**，里面的东西可以换；**常量**则是打上封条的**出厂赠品**，拆了封条（修改）编译器就会报警。
- **它解决了什么问题？**：如果没有类型和变量，你必须记住类似 `0x7ffd` 这种毫无意义的**物理地址**来存取数据，这就像不记朋友名字只记他的 GPS 经纬度一样痛苦且易错。

## 1.2 怎么用

- **核心规格表**：在主流 64 位系统中，规格如下：

|类型|关键字|占用字节 (Byte)|占用位 (Bit)|取值范围举例|
|:--|:--|:--|:--|:--|
|布尔型|`bool`|1|8|`true` / `false`|
|字符型|`char`|1|8|'A', '0', '\n'|
|整型|`int`|4|32|$\pm$ 21 亿|
|长整型|`long long`|8|64|天文数字|
|双精度浮点|`double`|8|64|15-16 位有效数字|

```
#include <iostream>
#include <cstdint> // 架构师标配：定宽类型

int main() {
    // 列表初始化：C++11 之后最安全的写法，防止精度丢失
    int count{100};

    // 运行时常量：初始化后就不能再赋值了
    const double kPi = 3.14159;

    // 编译期常量：让计算任务在程序起跑前就完成
    constexpr int kMaxBuffer = 1024 * 64;

    // 类型自动推导：让编译器自己根据初值猜类型
    auto distance = 500.5; // 被自动推导为 double

    return 0;
}
```

## 1.3 避坑指南

- **经典错误 1：局部变量不初始化**。C++ 不会自动给局部变量清零，它会随机抓取内存里残留的“口水”（垃圾数据），导致程序行为诡异。
- **经典错误 2：类型收窄 **。写 `int x = 3.94;` 时，`x` 会悄悄变成 3 而不报错。**正确做法**：使用 `{}` 初始化，编译器会强制拦截这种精度损失。
- **易混淆概念**：`const` 保证“只读”，但它的值可能在运行到那一行时才确定；而 `constexpr` 强迫编译器在**编译阶段**就把值算死，性能更强。
- **工程习惯**：在嵌入式开发中，我会包含 `<cstdint>`，直接使用 `int32_t` 或 `uint8_t`，确保代码在任何硬件上占用的位数都是一致的 。

# 2 底层原理

- **内存视角**：
    - **内存位置**：每个变量至少占据一个内存位置。标量类型（如 `int`）拥有独立位置。
    - **对齐填充**：为了让 CPU 读取更快，编译器会在 `char` 和 `int` 之间插入空字节，使 `int` 的地址是 4 的倍数。
- **编译器视角**：
    - **常量折叠**：编译器遇到 `constexpr` 时，会直接把计算结果填进机器指令，运行时 CPU 零开销。
    - **RVO**：现代编译器会直接在接收变量的地址上构造对象，消除不必要的拷贝。
- **硬件视角**：
    - **乒乓缓存**：多线程频繁读写同一变量会导致缓存行在核心间反复转移，性能剧降。
    - **伪共享**：互不相关的变量如果落在同一个 64 字节的缓存行内，也会引发硬件级的性能锁死。

# 3 总结

- **设计哲学**：C++ 遵循**零开销抽象**。如果你声明一个变量但从未使用，优化后的编译器会将其彻底抹除，不产生任何机器码。
- **现代 C++ 演进**：C++11 引入了 `nullptr` 取代 `0/NULL`，解决了指针与整数重载的歧义；C++20 引入了 `consteval` 强制函数必须在编译期执行。
- **实战**：在高并发系统中，利用 `alignas(64)` 强制变量占据独立缓存行，是解决多核竞争、压榨硬件性能的核武器。
- **一句话真相**：类型是数据的逻辑分类，而**长度和对齐**是数据在内存中的物理印记。

> [!question]
> - `char` 类型一定占 8 位吗？
>     - 不一定，C++ 标准只保证 `sizeof(char)` 为 1 字节。虽然目前主流设备是 8 位，但在某些特种 DSP 硬件上可能不同。
> - `const int *p` 和 `int * const p` 有什么区别？
>     - 前者是指针指向的内容不能改（保险箱里的东西不动）；后者是指针本身的指向不能改（保险箱的位置不动）。
> - 为什么在高性能编程中，即使两个变量逻辑独立，在结构体中紧挨着定义也会影响性能？
>     - 涉及**伪共享**。硬件以“缓存行”为单位同步，若两个变量在同一行，核 A 修改变量 1 会迫使核 B 的变量 2 缓存失效，产生巨大的总线开销。
