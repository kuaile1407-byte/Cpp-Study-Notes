---
tags:
  - 嵌入式/编程语言/CPP
number headings: " first-level l, start-at 1, max 6, l.l, auto, contents"
aliases:
---
> 如果喜欢看图文讲解，可点击下方链接，或搜索硬核萌新实验室
> - 小红书： http://xhslink.com/o/An70tZmfclv 
> - 公众号： https://mp.weixin.qq.com/s/29Ym7iSdmbZQko02tBK4MQ


> [!abstract] abstract  
> `switch-case` 是处理**离散值**多路分支的“直达电梯”，比 `if-else` 的“逐层爬楼”更高效，但在复杂状态管理中常被**多态**或**状态模式**取代。

# 1 基础概念

## 1.1 是什么？

- **直观定义**：它是代码世界里的“自动售货机”选号系统。
- **生活化比喻**：
    - **`if-else`** 像是你在大楼里找人：去 1 楼看不是，去 2 楼看不是，去 3 楼……（逐个判断）。
    - **`switch-case`** 像是坐电梯：你按下“5 楼”的按钮，电梯直接把你送到 5 楼，中间不停留。
- **核心作用**：当你有**很多**个确定的整数或枚举值（如星期一到星期日，菜单选项 1-5）需要判断时，它比写一长串 `else if` 更清晰、更整洁。

## 1.2 怎么用？

- **内置类型行为**：
    - `switch` 后面的括号里必须是**整型**（`int`、`long` 等）、**字符型**（`char`）或**枚举型**（`enum`）或者能隐式转换为整型的类型。
    - **不能**直接使用浮点数（`float`、`double`）或字符串（`string`）做判断，这是新手最常犯的错。
	    - 浮点数有精度问题，不适合精确匹配
	    - 字符串比较需要 `strcmp`，无法生成跳转表
- **标准范例**：

```cpp
#include <iostream>

void basic_switch() {
    int score_level = 2; // 假设 1=优秀, 2=良好, 3=及格

    // switch 括号里必须是整数或枚举，不能是区间！
    switch (score_level) {
        case 1:
            std::cout << "大神，受我一拜" << std::endl;
            break; // 必须写！否则会“滑落”到下一层
        case 2:
            std::cout << "不错，继续加油" << std::endl;
            break;
        case 3:
            std::cout << "万岁，没有挂科" << std::endl;
            break;
        default: // 类似 else，处理所有未匹配的情况
            std::cout << "未知等级，系统崩溃" << std::endl;
            break;
    }
}
```

- **优先级与常见陷阱**：
    - **漏写 break**：这是“天坑”。一旦匹配成功，程序会执行该 `case` 下的所有语句，**并自动执行后面所有 `case` 的语句**（直到遇到下一个 `break`）。

## 1.3 常见错误

- **经典错误 1**：**把 switch 当 if 用**。
    - *错误现象*：`switch (score > 60)`。
    - *正确做法*：`switch` 只用于**点对点**的数值匹配。如果是范围判断（如大于、小于），老老实实去写 `if-else`。
- **经典错误 2**：**case 后面的值重复**。
    - *错误现象*：两个 `case` 写了同一个数字。
    - *编译器行为*：直接报错，`case` 必须是唯一的常量表达式。
- **易混淆概念**：`break` 在 `if` 里没用（`break` 的设计目的是**跳出当前循环或 switch 语句**，而不是 `if` 语句。`if` 语句本身执行完就自然结束，不需要跳出），但在 `switch` 里是救命稻草，用于跳出整个 switch 结构块。

# 2 进阶实战

## 2.1 进阶用法

- **为什么要进阶？**：
    - 在大型系统中，如果我们的 `switch` 有几十个 `case`，代码会变得极其难看且难以维护。这时候需要用设计模式来消灭 `switch`。
    - 有时我们可以故意不写 `break`，让多个 `case` 执行同一段逻辑。

```cpp
#include <iostream>

enum class LogLevel { INFO, WARNING, ERROR, FATAL };

void print_log(LogLevel level) {
    switch (level) {
        case LogLevel::FATAL:
            std::cout << "[发送报警短信] ";
            // 故意没有 break，FATAL 也需要记录日志
        case LogLevel::ERROR:
            std::cout << "[写入数据库] ";
            // 故意没有 break
        case LogLevel::WARNING:
        case LogLevel::INFO:
            std::cout << "日志内容…" << std::endl;
            break;
    }
}
```

## 2.2 常见错误

- **变量定义作用域**：
	- *问题*：在 `case` 下面直接定义变量 `int x = 10;`。
	- *为什么*：如果程序跳过了这个 case 进入下一个，变量 `x` 就会处于**未初始化**状态，编译器会报错。
	- *怎么改*：加上大括号 `{ int x = 10; … }` 限制作用域或在 `switch` 外部定义变量。

```cpp
#include <iostream>
using namespace std;

int main() {
    int choice = 1;
    
    switch (choice) {
        case 1:
            int x = 10;  // 错误！变量作用域会穿透到整个 switch
            cout << "x = " << x << endl;
            break;
        case 2:
            // 如果跳到这里，x 可能未初始化！
            // cout << x << endl;  // 编译错误！
            cout << "Case 2" << endl;
            break;
    }
    return 0;
}
```

这个问题在使用类对象时更加危险：

## 2.3 工程习惯

- **多态代替 Switch**：[[多态代替Switch|代码示例]]
    - 如果你发现自己在根据对象的类型写 `switch`（例如 `switch(shape.type) case Circle: … case Square: …`），请立即停止！
    - **老司机写法**：使用**虚函数**（多态）。让 `Circle` 和 `Square` 各自实现 `draw()` 函数，外部直接调用 `shape->draw()`。这符合开闭原则，加新图形不用改 switch 代码。
- **状态机（FSM）**：[[状态模式替换switch|代码示例]]
    - 在嵌入式开发中，`switch` 常用于简单的状态机。但状态复杂时，应升级为**状态模式**，将每个状态封装成独立的类，避免 `switch` 爆炸。

# 3 底层原理

## 3.1 编译器视角

- **编译器背地里做了什么？**
    - **跳转表**：当 `case` 的值比较密集时（如 1, 2, 3, 4），编译器会生成一个函数指针数组（跳转表）。
    - **O(1) 复杂度**：`switch` 不会像 `if-else` 那样傻傻地逐个比较。它直接用输入的值作为数组下标，**瞬间跳转**到目标代码地址。这就是为什么我们前面说它是**直达电梯**。
    - **二分查找**：如果 `case` 值很稀疏（如 1, 1000, 50000），编译器可能会优化为二分查找树，而不是生成巨大的跳转表。
	    - 这是一种典型的**以空间换时间**的策略。如果我们的 `case` 值非常稀疏（例如 1, 10000, 1000000），编译器为了避免建立巨大的空表浪费内存，会退化为 **二分查找树**（`O(log N)`）甚至普通的 **if-else **（`O(N`)）。

## 3.2 内存与性能

- **编译期优化**：
    - **Int2Type 技术**：在模板元编程中，可以利用模板特化来充当编译期的 `switch`。通过 `Int2Type<v>` 将一个整数映射为一个类型，从而在编译期决定调用哪个函数，完全消除了运行时的分支开销。
    - **静态分派**：`switch` 是运行时分派，`Int2Type` 属于编译器分派或静态分派，而 `std::visit` (C++17) 属于更加类型安全的运行时分派方式。

# 4 总结

## 4.1 设计哲学

- **结构化控制**：`switch` 的设计初衷是处理**离散**的、**枚举型**的决策逻辑。它是 C++ 继承自 C 语言的高效遗产。
- **反模式警示**：在面向对象设计中，过长的 `switch` 往往是坏代码，意味着你违反了面向对象的封装和多态原则。

## 4.2 现代 C++ 演进

- **`enum class` (C++11)**：强类型枚举。配合 switch 使用时，必须显式匹配类型，防止了隐式转换带来的 Bug。
- **模板元编程**：利用 `Int2Type` 等技术，`C++` 将 `switch` 的思想提升到了**编译期**，实现了针对不同数值常量的静态代码选择，这是高性能库（如 Loki, Boost）的核心技巧。

## 4.3 一句话总结

**`switch` 是底层的性能利器，但在高层架构中，它往往是多态缺失的替补；新手用它做逻辑，高手用它做底层优化的跳转表。**

> [!question] 面试自测
>
> - `switch` 的参数能是 `double` 吗？为什么？
>     - *答案*：不能。必须是整型、字符型、枚举或者能隐式转换为整型的类型。因为浮点数比较存在精度误差，且难以直接映射为跳转表的索引。
> - 在 `case` 语句中定义变量为什么会报错？如何解决？
>     - *答案*：因为 `switch` 的跳转可能跳过变量的初始化语句。解决方法是用 `{}` 将该 case 的代码包围起来，形成独立的块作用域。
> - 请解释双分派以及它如何解决 `switch` 在处理两个多态对象交互时的局限性（例如 `Shape` 和 `Printer` 的交互）。[[双分派详解]]
>     - *核心思路*：单次虚函数调用只能根据一个对象的类型动态分派。如果操作取决于两个对象的类型，单纯用 `switch` 会导致类型检查代码爆炸。通过两次虚函数调用（第一次 `accept`，第二次 `visit`）实现了双分派，优雅地替代了嵌套的 `switch-case`。
