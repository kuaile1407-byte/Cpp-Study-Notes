---
tags:
  - 嵌入式/编程语言/CPP
number headings: " first-level l, start-at 1, max 6, l.l, auto, contents"
---
> 如果喜欢看图文讲解，可点击下方链接，或搜索硬核萌新实验室
> - 小红书： http://xhslink.com/o/713sgq0FBb5 
> - 公众号：
> - 抖音：

> [!abstract]  
> **变量**与**常量**是程序的物理载体，通过具名的**内存位置** 提供受控的数据存储，并利用 `const` 与 `constexpr` 确立程序的**不变量**以确保安全与性能。

# 1 基本概念

## 1.1 是什么

- **一句话定义**：**变量**是给某块特定内存地盘取的绰号，而**常量**是给这块地盘焊上的只读锁。
- **生活化比喻**：内存像宾馆，**变量**是租下的带房号的房间，里面的客人（数据）可以随时换。**常量** (`const`) 则是房门被焊死的房间，里面的摆设一旦放进去就再也动不了了。
- **它解决了什么问题？**：在没有它们之前，程序员只能直接处理原始的**二进制地址**（如 0x7ffd…），这就像不记朋友的名字而记他的 GPS 经纬度一样，代码完全没法读。

## 1.2 怎么用

- **基础语法**：

```cpp
int age;           // 声明变量（占坑但未入住，值不确定）
age = 18;          // 赋值
const float PI = 3.14f; // 符号常量（必须在声明时初始化）
```

- **标准范例**：

```cpp
#include <iostream>

int main() {
	// 推荐：C++11 列表初始化 {}，防止类型收窄导致精度丢失
	int balance{1000};

	// 自动类型推导：让编译器根据初始值自己猜类型
	auto price = 12.5;

	// 编译期常量：强制在程序跑起来前就完成计算
	constexpr int kMaxUsers = 100 * 50;

	return 0; // 现代c++可以省略，编译器会自动添加
}
```
    
- **常见写法对比**：
    - **写法 A**：`int x = 1.9;` —— 隐式转换，`x` 会悄悄截断成 1，编译器可能不报错。
    - **写法 B**：`int x{1.9};` —— **列表初始化**，编译器会因精度损失直接报错，安全感拉满。
- **边界情况**：在类声明中，非静态成员变量可以使用 = 或 `{}` 就地初始化，但不能使用 `()` 方式

## 1.3 常见错误

- **经典错误 1：未初始化变量**。局部变量若不给初值，它会随机抓取内存里残留的“垃圾数据”，导致程序产生难以预料的行为。
- **经典错误 2：混淆 `const` 和 `constexpr`**。`const` 只是保证运行时只读，它的值可能在运行到那一行时才确定；而 `constexpr` 要求必须是编译期已知的真常量，能显著提升执行性能。

在 嵌入式开发中，`RAM` 极贵。可以优先将配置设为 `constexpr`，让它们留在 `ROM` 中，既省空间又防多线程初始化时的**条件竞争**

# 2 原理

- **内存视角**：
    - 每个变量都至少占据一个**内存位置** 。哪怕是 1 字节的 `char` 也要占一个物理格子。
    - **相邻位域陷阱**：在结构体中，相邻的**位域**共享同一个内存位置，多线程同时修改不同位域时会引发**数据竞争**。
- **编译器视角**：
    - 编译器遇到 `constexpr` 会执行**常量折叠**，直接把计算结果填进机器指令。
    - 对于某些 `const` 常量，编译器可能直接将其记录在符号表中，连内存地址都不分配。
- **硬件视角**：
    - **乒乓缓存**：若多线程频繁读写同一个变量，会导致该变量所在的**缓存行**在不同 CPU 核间反复同步，性能可能下降 90% 以上。

# 3 总结

- **设计哲学**：C++ 遵循**零开销抽象**。变量声明后若不使用，编译器会直接将其抹除，不留任何机器指令。
- **现代 C++ 演进**：C++11 引入了 `nullptr` 替代 `0/NULL`，增强了指针安全性；C++20 引入了 `consteval` 强制函数必须在编译期执行。
- **实战**：在高并发场景下，为了榨干多核性能，工程师会通过 `alignas` 对变量进行**内存对齐**，确保互不相关的变量不在同一个缓存行，从而避免**伪共享**。
- **一句话真相**：变量是**物理地址**的语义包装，而类型系统是内存布局的**说明书**。

> [!question]
> - 局部变量如果不显式初始化，它的值是多少？
>     - **答案**：其值是不确定的垃圾数据，读取它属于未定义行为。
> - `const` 引用一定能保证它引用的对象绝对不被修改吗？
>     - **答案**：不能。`const` 引用仅限制了通过这个引用不能改。如果该对象还有其他非 `const` 的指针或引用，其值仍可能在背后改变。
> - 为什么在高性能编程中，即便两个变量逻辑上独立，在结构体中紧挨着定义也可能影响性能？
>     - 涉及**伪共享**。因为硬件缓存以缓存行（通常 64 字节）为单位。若变量 A 和 B 落在同一行，核 1 修改 A 会迫使核 2 的 B 缓存失效，产生频繁的核间同步开销。
